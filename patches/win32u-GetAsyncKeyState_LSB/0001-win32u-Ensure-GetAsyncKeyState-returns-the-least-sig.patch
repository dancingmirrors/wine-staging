From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Wine Staging <wine-staging@winehq.org>
Date: Mon, 2 Dec 2024 00:00:00 +0000
Subject: [PATCH] win32u: Track key transitions for GetAsyncKeyState LSB.

Some applications, such as Boris Vorontsov's ENB for Skyrim, rely on
the least significant bit (0x0001) of GetAsyncKeyState's return value
to detect when a key was pressed since the last call. This bit should
indicate that the key has transitioned from up to down.

Wine's implementation relies on the server's 0x40 flag in the desktop
keystate, but this flag may be cleared before the application can read
it, especially with high-frequency polling. This patch adds client-side
tracking of key transitions to ensure the LSB is returned correctly
when a key press is detected.

Note: Microsoft's documentation warns that the LSB is unreliable due
to preemption - another application could receive the bit instead.
This client-side tracking provides per-process semantics which is
actually more reliable for applications like ENB that need to detect
their own key presses.

This fixes keybinding issues in Boris ENB and similar applications
that poll GetAsyncKeyState for key transitions.
---
 dlls/win32u/input.c | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)

diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -40,6 +40,10 @@
 WINE_DEFAULT_DEBUG_CHANNEL(win);
 WINE_DECLARE_DEBUG_CHANNEL(keyboard);
 
+/* Track previous key states for GetAsyncKeyState LSB detection */
+static BYTE prev_async_keystate[256];
+static pthread_mutex_t async_keystate_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 static const WCHAR keyboard_layouts_keyW[] =
 {
     '\\','R','e','g','i','s','t','r','y',
@@ -805,6 +809,17 @@ SHORT WINAPI NtUserGetAsyncKeyState( INT key )
     while ((status = get_shared_desktop( &lock, &desktop_shm )) == STATUS_PENDING)
         state = desktop_shm->keystate[key];
 
+    /* Track key transitions: detect when key goes from up to down */
+    pthread_mutex_lock( &async_keystate_mutex );
+    if ((state & 0x80) && !(prev_async_keystate[key] & 0x80))
+    {
+        prev_async_keystate[key] = state;
+        pthread_mutex_unlock( &async_keystate_mutex );
+        return (SHORT)(0x8001);
+    }
+    prev_async_keystate[key] = state;
+    pthread_mutex_unlock( &async_keystate_mutex );
+
     if (status) return 0;
     if (!(state & 0x40)) return (state & 0x80) << 8;
 
-- 
2.43.0
